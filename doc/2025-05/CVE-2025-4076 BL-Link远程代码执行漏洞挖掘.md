#  CVE-2025-4076 BL-Link远程代码执行漏洞挖掘   
原创 Gray  ChaMd5安全团队   2025-05-15 00:01  
  
> 招新小广告CTF组诚招re、crypto、pwn、misc、合约方向的师傅,长期招新IOT+Car+工控+样本分析多个组招人有意向的师傅请联系邮箱 admin@chamd5.org(带上简历和想加入的小组)    
  
  
### 漏洞描述  
  
漏洞复现设备：BL-AC3600  
  
漏洞原理：路由器中存在远程代码执行  
  
简述:该漏洞存在于BL-AC3600及更高版本，文件 /cgi-bin/lighttpd.cgi 中的 easy_uci_set_option_string 函数。对 routepwd 参数的操作会导致命令注入。攻击者可以利用该漏洞远程发起攻击。  
### 固件模拟  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkocspTxBw6ak74icJaH9KQLjGITgsyvQ4Fgv5qwceK8Qsf6zhM9MImkWA/640?wx_fmt=png&from=appmsg "")  
  
mips32小端序，还是MipsR3000，尝试firmae之类  
的自动化工具，但无法直接模拟，因此  
还是采用qemu模拟。  
  
首先需要去模拟一个固件所依赖的环境  
```
make list-defconfigs
```  
  
默认给出的配置文件可以通过这个指令查询  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkol2Y7xZBS4ZrHmAwddJcpdibXyNS3b5LuibQHlyELLzNEzSGR68QrEaJA/640?wx_fmt=png&from=appmsg "")  
  
这里选用qemu_mips32r2el_malta_defconfig生成配置文件  
```
make qemu_mips32r2el_malta_defconfig
```  
  
这一步会让我们的menuconfig自动根据想搭建的环境进行配置  
  
但只是基础配置，想开启openssh之类的还得自己去里面改  
```
make menuconfig
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkorVBZHSNg62iaBBbuQxt6CNic58ATpGQ7WeTuC1hWxmgMiaa7B6qNETrWg/640?wx_fmt=png&from=appmsg "")  
  
第一个Target options就是设置镜像，像模拟的环境，大小端序之类的，都是在里面  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoq0iawNOD5B1dfnlhAc9mf0HuZMG9ymAib8QprBcmiaGt1cRXiaPp9xrqow/640?wx_fmt=png&from=appmsg "")  
  
第六个Target packages就是配置目标包  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoAdIxammPf0zaGwlDczicGfhic4XzDr05FpCWicLJvLP1gI7EYFs5TIdOQ/640?wx_fmt=png&from=appmsg "")  
  
进入这个networking开启我们之后需要的  
  
bridge-utils  
  
openssh-server  
  
如果没有就是缺少对应的环境，需要自己下  
```
sudo apt install bridge-utilssudo apt install openssh-server
```  
  
make编译好后启动文件应该会放在/buildroot-2024.08.2/output/images/下，不过默认的start-qemu.sh只有基本的启动项，为了方便我们之后传固件和做调试，可以修改sh文件  
```
#!/bin/shBINARIES_DIR="${0%/*}/"# shellcheck disable=SC2164cd "${BINARIES_DIR}"mode_serial=falsemode_sys_qemu=falsetap_interface="tap0"  # 默认的TAP接口名称tap_ip_host="192.168.100.1"  # 宿主机的IP地址tap_ip_guest="192.168.100.2"  # 虚拟机的IP地址while [ "$1" ]; do    case "$1" in    --serial-only|serial-only) mode_serial=true; shift;;    --use-system-qemu) mode_sys_qemu=true; shift;;    --tap-interface) tap_interface="$2"; shift 2;;    --use-tap) use_tap=true; shift;;    --) shift; break;;    *) echo "unknown option: $1" >&2; exit 1;;    esacdoneif ${mode_serial}; then    EXTRA_ARGS='-nographic'else    EXTRA_ARGS='-serial stdio'fiif ! ${mode_sys_qemu}; then    export PATH="/home/blonet/Desktop/buildroot-2024.08.2/output/host/bin:${PATH}"fiif ${use_tap}; then    # 创建并配置TAP接口    sudo ip link delete "${tap_interface}" 2>/dev/null  # 如果 TAP 接口已存在，先删除    sudo ip tuntap add dev "${tap_interface}" mode tap  # 创建 TAP 接口    sudo ip addr add "${tap_ip_host}/24" dev "${tap_interface}"  # 为 TAP 接口分配宿主机IP地址    sudo ip link set "${tap_interface}" up  # 启用 TAP 接口    # 配置 QEMU 使用 TAP 网络    NET_CONFIG="-netdev tap,id=net0,ifname=${tap_interface},script=no,downscript=no -device pcnet,netdev=net0"else    # 使用用户模式网络    NET_CONFIG="-net nic,model=pcnet -net user"fiexec qemu-system-mipsel -M malta \    -kernel vmlinux \    -drive file=rootfs.ext2,format=raw \    -append "rootwait root=/dev/sda console=ttyS0 ip=${tap_ip_guest}::${tap_ip_host}:255.255.255.0::eth0:off" \    ${NET_CONFIG} ${EXTRA_ARGS} "$@"
```  
  
启动登录后在模拟出的环境下再创建个接口  
```
ip addr add 192.168.100.2/24 dev eth0ip link set eth0 up//在虚拟机内部，配置其网络接口（例如 eth0）以与宿主机在同一网段
```  
  
可以ping一下能不能和宿主机ping通  
  
更改设置  
  
利用busybox里的vi修改）  
```
vi /etc/ssh/sshd_config
```  
  
找root登录对应行  
  
把注释去掉，后面的后缀改成 yes  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoM0qUey3Ly6WaFY1SfOEX8XPon6337yribnqBj79fuA3gOlzrWq2kCGA/640?wx_fmt=png&from=appmsg "")  
  
传输固件，提一点如果宿主机openssh版本比较新会有报错因为现代 SSH 客户端（如 OpenSSH 8.8 及以上版本）默认禁用了 ssh-rsa  
和 ssh-dss  
密钥类型，因为它们被认为不够安全。  
  
不过加入-o HostKeyAlgorithms=+ssh-rsa就能解决  
```
sudo scp -r squashfs-root/ root@192.168.100.2:~/#sudo scp -o HostKeyAlgorithms=+ssh-rsa -r squashfs-root/ root@192.168.100.2:~/chmod -R 777 squashfs-root/
```  
  
挂载固件  
```
mount -o bind /dev ./squashfs-root/devmount -t proc /proc ./squashfs-root/procchroot squashfs-root/ /bin/sh
```  
  
在固件目录里能找到lighttpd文件，这就是LBlink所使用的webserver服务，去etc文件夹找相关配置  
  
拉起webserver主程序  
```
/usr/sbin/lighttpd -f /etc/lighttpd/lighttpd.conf
```  
  
这里启动的时候会有个报错  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWko7Va0UwsF3v5lgB4diadYEL1kn7AG3quaou5ly6h6tH45wrFq8rDFicFQ/640?wx_fmt=png&from=appmsg "")  
  
提示缺少/var/lighttpd.pid，应该是少了一个日志文件导致无法启动，创建对应文件  
```
mkdir -p /var/run/touch lighttpd.pid//去run文件夹下创建chmod 777 lighttpd.pid
```  
  
还需要启动ubusd服务/sbin/ubusd start  
  
再次启动lighttpd  
  
还有一个办法就是直接找附带内核，配置文件的整合包拉起  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoCzMmZGIXoMPRZlsohZz06MJBVXKXFNb8PDgu7vSuGNdAOYTI8tS8gw/640?wx_fmt=png&from=appmsg "")  
### 逆向分析与漏洞挖掘  
  
开始做逆向分析的时候，可以实现的切入点就会多很多  
  
我自己的习惯还是利用emba,firmwalker这种分析工具跑的同时自己去人工审一下  
  
一般最先下手的还是CGI这类直接接收用户输入的接口  
  
先来看下firmwalker的分析结果  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWko2NhoVGOicd8KuvFibKxaYlsY2ia1CvsdT0iaToYavEtXqPiardc2DJUtneg/640?wx_fmt=png&from=appmsg "")  
  
像这边给出的就是一个md5加密后的管理员口令  
  
还有就是  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkochvwKmBgibCuhjzNH2LsgBUmbRaQsPE6icHuhiaModITjjLpflYNXDnLw/640?wx_fmt=png&from=appmsg "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoibiaVooeQjh9TBlnfSgSaPWacXsgu4hib16L5bXc64kyt9SJ3BLaRUvOg/640?wx_fmt=png&from=appmsg "")  
  
这种firmware.sh，upgrade文件夹下的内容很可能就是固件升级相关的逻辑，  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoxiaAXrI8ccvKZSib8L7jFR2GWu3PDQeyjnmBENY5Sxw7cC6cLIBrM57g/640?wx_fmt=png&from=appmsg "")  
  
设备开启的telent接口，之后就可以考虑命令注入开启telent反弹shell  
  
包括还有一个 /usr/lib/libblinkapi.so 文件  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoIHXV1FEUhicn2tCGOAZgH3kCRe6G50Z6KEXDzRySLJdAetIE1kEIaZQ/640?wx_fmt=png&from=appmsg "")  
  
不出意外是个API动态链接库 ，这种都是重点的分析对象  
  
我们可以去对一些功能点抓个包，比如修改密码这种功能点  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoBl8hEsWicZkurgWEPqI3W37DBOnBQm49aTkUR1Vlw9MRusicPMrEmziaQ/640?wx_fmt=png&from=appmsg "")  
```
POST /cgi-bin/lighttpd.cgi HTTP/1.1Host: 192.168.242.146:4567Content-Length: 44Accept: application/json, text/plain, */*Authorization: b0dd4dc52634f779d398d38f3beba06dUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.93 Safari/537.36Content-Type: application/x-www-form-urlencodedOrigin: http://192.168.242.146:4567Referer: http://192.168.242.146:4567/html/index.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: user=adminConnection: close{"type":"setmanpwd","routepwd":"123123avbc"}
```  
  
可以很明确的看到是 lighttpd.cgi 这个cgi脚本在处理这个请求  
  
去分析一下这个脚本  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWko8aAxsQo6p6BOZrU1NoLhTDCAg0ic9esqBAxDjaYgwTxescyNmeKuxJg/640?wx_fmt=png&from=appmsg "")  
  
对请求进行了一些验证，之后调用了share_func来对json数据做进一步处理  
  
share_func是一个动态链接的函数，我要去找到对应的DLL文件  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoWXq0ZUfgicP5GNsOxoxPezgmNeCEmrOffx1h3sn4ynIlRWDBlHZM3Ug/640?wx_fmt=png&from=appmsg "")  
  
又出现了刚刚说的libblinkapi.so文件，  
  
去libblinkapi.so里分析一下这个share_func  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWko6GFqvYaL0WYD4fsPGaFKU6tUmaVSRaZblj5ictGXlM5P7IibQp1mTlQA/640?wx_fmt=png&from=appmsg "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWko8nkiceSFlwrDbcX0L0PHzJOGWlsEt4cOn3GPNGlRyLiarMUoAEw3LK6g/640?wx_fmt=png&from=appmsg "")  
  
接收了json数据给了v13  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoI4ulCkN2iadx0y5FIEPa9alULNLqma1ibXDhuWyT9w327DthCiclu5jOg/640?wx_fmt=png&from=appmsg "")  
  
访问字符串常量数组aCfgType， 偏移了一个固定值，最后读到的就是type了  
  
把type类读到了v4，  
  
把type对应的值，也就是setmanpwd给了v15  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoteibSdyvV2v3E6RAjJtl4n1m6f3CcY4D9EwkXUWkaicYD6PMKxqOibuCw/640?wx_fmt=png&from=appmsg "")  
  
v15转存到了v20  
  
在下面遍历指针表，寻找匹配的函数，如果找到了就会调用这个函数，json数据也会再交给那个函数处理  
  
setmanpwd对应的函数  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoKHzIG1EquLPAcWdC4gqiamFEeLQX761kqaBQc3ep1ojTlvNBMA31tFw/640?wx_fmt=png&from=appmsg "")  
  
分析一下这个函数，函数逻辑还是比较简单的  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoxXxgYcZffibmSZbqTaXoIUqqPh9Dyt5vSTn7O1MAaaqBibCxYFg0fXDw/640?wx_fmt=png&from=appmsg "")  
  
创建了两个缓冲区  
  
把缓冲区给了v24  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoLib8V5mVGMBldFOYRWXZ0V5rn0DDM4BMcEKHibzrobDrfRArq3dWculw/640?wx_fmt=png&from=appmsg "")  
  
做了个空json的检查  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoLowBZVdDUTy7vSxapR8icL8ibVwrQiatl7V5q0zVic97zic6BTKqX9NjuMw/640?wx_fmt=png&from=appmsg "")  
  
其实就是构造了一个 v17为 cfgType: setmanpwd  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/PUubqXlrzBQCib4D2DyQskpKvQsTyBWkoSibDpkSm74TTMkkJsFd3KOLgepYEEcQBOib0bL82ak5ficemzP9dicgwXA/640?wx_fmt=png&from=appmsg "")  
  
针对我们输入的密码其实没做什么过滤，最后拼接到chpasswd.sh root后就被执行了  
  
换句话来讲，只要我们做一点简单的分割加个管道符就能实现命令注入  
  
只要在我们的抓包数据里去修改一下"routepwd":"123123avbc"就可以实现注入了  
  
漏洞整体逻辑还是比较简单的，主要是分享一下本人在挖掘这个漏洞时的思路  
  
这个漏洞已经被公开，其他信息可以在nvd看到  
  
nvd链接:https://nvd.nist.gov/vuln/detail/CVE-2025-4076  
  
结束  
  
  
招新小广告  
  
ChaMd5 Venom 招收大佬入圈  
  
新成立组IOT+工控+样本分析   
长期招新  
  
欢迎联系  
admin@chamd5.org  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_png/PUubqXlrzBR8nk7RR7HefBINILy4PClwoEMzGCJovye9KIsEjCKwxlqcSFsGJSv3OtYIjmKpXzVyfzlqSicWwxQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
